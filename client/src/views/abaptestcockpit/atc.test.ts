import { extractPragmas, insertPosition } from "./functions"


test("extract pseudocomment notext", async () => {
    const doc = "<h3>Details of Analysis</h3><p>Strings without text elements are not translated: 'foo bar !'</p><p>The message can be suppressed with pseudo comment NOTEXT</p><h3>What is checked?</h3><p>This check ensures that customers do not see any foreign language texts.</p><h3>Procedure</h3><p>It is possible to use the rules below to flag a character string as non&ndash;text&ndash;like (for example, by using only uppercase characters). As a final resort, it may sometimes be necessary to suppress the message using a pragma.</p><pre><code>string = 'Data Hugo TYPE I.' ##NO_TEXT .</code></pre><h3>How is the check done?</h3><p>The check examines all character strings without text elements that can potentially be displayed. This includes the <CODE>VALUE</CODE>s specified for fields and constants for which a text element cannot be specified directly. The character strings are checked for texts that need to be translated using the following criteria:</p><ol><li>The character string is longer than three characters.</li><li>The character string contains at least one uppercase and lowercase character.</li><li>If the character string consists of only one word, an uppercase letter can only be at the start of this word</li><li>Any workflow macro names (words that begin with <CODE>SWC_</CODE>) are ignored. Character strings that obviously are not used for output, for example <CODE>FORM</CODE> names or character strings in conditions, are ignored.</li></li></ol>"
    const x = await extractPragmas(doc)
    expect(x).toEqual([`"#EC NOTEXT`])
})

test("extract pragma notext", async () => {
    const doc = "<h3>Details of Analysis</h3><ul><li>Strings without text elements are not translated: 'Error in DOCU_GET'</li><li>Finding can be suppressed with pragma ##NO_TEXT</li></ul><h3>What is checked?</h3><p>This check ensures that customers do not see any foreign language texts.</p><h3>Procedure</h3><p>It is possible to use the rules below to flag a character string as non-text-like (for example, by using only uppercase characters). As a final resort, it may sometimes be necessary to suppress the message using a pragma.</p><pre><code>string = 'Data Hugo TYPE I.' ##NO_TEXT .</code></pre><h3>How is the check done?</h3><p>The check examines all character strings without text elements that can potentially be displayed. This includes the <CODE>VALUE</CODE>s specified for fields and constants for which a text element cannot be specified directly. The character strings are checked for texts that need to be translated using the following criteria:</p><ol><li>The character string is longer than three characters.</li><li>The character string contains at least one uppercase and lowercase character.</li><li>If the character string consists of only one word, an uppercase letter can only be at the start of this word</li><li>Any workflow macro names (words that begin with <CODE>SWC_</CODE>) are ignored. Character strings that obviously are not used for output, for example <CODE>FORM</CODE> names or character strings in conditions, are ignored.</li></li></ol>"
    const x = await extractPragmas(doc)
    expect(x).toEqual([`##NO_TEXT`])
})


test("extract pseudocomment nobreak", async () => {
    const doc = "<h3>Details of Analysis</h3><p>The line contains a BREAK&ndash;POINT statement.</p><p>The message can be suppressed with pseudo comment NOBREAK</p><h3>Extended Program Check (Transaction SLIN)</h3><h2>Overview</h2><p>The &quot;Extended Program Check&quot; performs static checks on ABAP programs that are too intensive for the regular syntax check. It can be called using transaction code SLIN and directly from the development tools for ABAP programs.</p><p><STRONG>Note</STRONG></p><p>The errors, warnings, and messages displayed by the extended program check are just as important as the syntax errors and syntax warnings from the syntax check. For example, an error reported by the &quot;Extended Program Check&quot; can indicate that a program definitely produces a runtime error when it is executed. Warnings and messages usually indicate a questionable use of language elements, which is likely to cause unexpected program behavior. See also the associated <a href=\"https://myserver.com/sap/public/bc/abap/docu?sap-language=EN&sap-client=100&format=ECLIPSE&object=ABENEXTENDED_PROGRAM_CHECK_GUIDL\">programming guidelines</a>.</p><h2>Prerequisites</h2><p>Prerequisites for running the &quot;Extended Program Check&quot; are:</p><ul><li>Only full compilation units such as standalone programs, function groups, class pools, interface pools, and type groups are checked. Non&ndash;included include programs cannot be checked.</li><li>Only programs with correct syntax and that can be generated are checked.</li><li>Only programs with correct program types are checked.</li><li>Only the active version of a program is checked.</li><li>In customer systems, only customer programs can be checked (in most cases). Here, SAP programs can be checked only up to one week after a source code change. This supports corrections to SAP programs in customer systems. An exception to this are the security checks. These cannot be used to check any SAP programs in customer systems.</li></ul><p>If these prerequisites are not met, an appropriate message is displayed and no analysis is performed.</p><h2>Use</h2><p>The &quot;Extended Program Check&quot; can run in two ways:</p><ul><li>Execute &quot;Selected Checks&quot; (default setting)<br>  <p>The default setting (&quot;Run Selected Checks&quot;) in transaction SLIN performs the selected checks when the &quot;Run Checks&quot; (F8) pushbutton is chosen. For performance reasons, and to make them easier to use, the selectable checks are divided into 20 separate subchecks. For information about what is checked by the subchecks, display the F1 help. The subchecks can be activated and deactivated in any number of combinations. Messages are displayed by severity (error, warning, or information).</p></li><li>Execute &quot;ATC&ndash;Relevant Checks&quot;<br>  <p>Choose the option &quot;Run ATC&ndash;Relevant Checks&quot; to display the errors from all 20 subchecks that are particularly critical (namely ATC&ndash;relevant). Messages are displayed in accordance with the severity defined in ABAP Test Cockpit (ATC). This does not include</p><ul><li>local changes to the severity or</li><li>exceptions</li></ul><p></p><p>defined for ATC.</p></li></ul><p>The &quot;Extended Program Check&quot; can take up to 10 times as long as a normal syntax check. However, they do use an internal cache, so if used repeatedly, the runtime does become significantly shorter. This applies in particular to repeated executions of &quot;ATC&ndash;Relevant Checks&quot;.</p><p>If the option &quot;Display all check results in a list&quot; is not activated, the results are displayed in an overview. Double&ndash;clicking displays the error description(s) and from there the corresponding position(s) in the source code.</p><p><STRONG>Saving the chosen options</STRONG></p><p>If you want to save the selected options for future extended program checks, choose the &quot;Save&quot; pushbutton (or use Ctrl+S).</p><p>These saved settings are applied each time the extended program checks are started.</p><p><STRONG>Deleting saved options</STRONG></p><p>You can delete your saved options by choosing the &quot;Delete User Settings&quot; pushbutton (or by using F9).</p><p><STRONG>Note</STRONG></p><p>The security checks comprise a subcheck that is subject to a special licensing procedure. More information about the security checks is available in the documentation for the program<a href=\"https://myserver.com/sap/public/bc/abap/toolsdocu?id=TX&obj=BC_SLINSEC_SETUP_INFO&lang=E&sap-language=EN&sap-client=100\">RSLIN_SEC_LICENSE_SETUP</a>.</p>"
    const x = await extractPragmas(doc)
    expect(x).toEqual([`"#EC NOBREAK`])
})

test("no pseudocomment", async () => {
    const doc = "<h3>Details of Analysis</h3><p>Missing authorization check in report YMULOADTASK</p><p>Cannot be hidden using a pragma or pseudo&ndash;comment</p><h3>What is checked?</h3><h3>Potentially missing authorization check in a report</h3><p>Message number 11A1</p><p>Authorization checks should be used to secure reports against being called by unauthorized users.</p><h3>Procedure</h3><p>Check whether an authorization check exists for this report and, if necessary, add a check at the start of the report. If the report is already being used or has been delivered, a switchable authorization check should be integrated using the method call <CODE> CL_SACF=>AUTH_CHECK_SPEC( )</CODE>.</p><p>It is also possible to assign an authorization group to the report, in which case an authorization check does not need to be integrated and no message is displayed (if the group is entered in database table TPGP and hence valid). The authorization group can be entered in the attributes of the report.</p><p>If the source code position in question does not have any security problems and there is no point in modifying the source code, an <a href=\"https://myserver.com/sap/public/bc/abap/toolsdocu?id=CHAP&obj=BC_SLINSEC_EXEMPTS&lang=E&sap-language=EN&sap-client=100\">exemption</a> should be requested in ATC.</p><h3>How is the check done?</h3><p>The report is scanned for certain authorization checks and risky statements (see below), which entails the report code (including form routines, dynpro modules, functions calls, and method calls) being scanned.</p>"
    const x = await extractPragmas(doc)
    expect(x).toEqual([])
})

test("sel nested pseudocomment", async () => {
    const doc = "<h3>Details of Analysis</h3><p>NonLocal Nested Reading DB OP (SELECT) found</p><p>The message can be suppressed with pseudo comment CI_SEL_NESTED</p><h2> <a href=\"https://myserver.com/sap/public/bc/abap/toolsdocu?id=TX&obj=S_CODE_INSPECTOR&lang=E&sap-language=EN&sap-client=100\">Code Inspector</a></h2><p><STRONG>Find database operations in nested loops across modularization units</STRONG></p><p>This check searches for database operations that are nested inside any kind of loop (e.g. LOOP&ndash;loop, DO&ndash;loop, ...)<CODE>. </CODE>If in the loop there is a call to a modularization unit (<CODE>PERFORM, CALL FUNCTION, CALL METHOD</CODE>), then this call is tracked and it will be analyzed, whether there is a database operation in the called unit. This way, several levels of the call&ndash;stack are analyzed (for runtime reasons, there is an upper limit for the call&ndash;stack depth).</p><p><STRONG>What you can do:</STRONG><br> If a database operation is executed inside a loop for several entries of the internal table that is processed, please check whether it is possible to read or write the needed database lines with one database statement instead. For example, it could be possible to replace the <CODE>SELECT</CODE> inside the <CODE>LOOP</CODE> with a <CODE>SELECT ... FROM dbtab FOR ALL ENTRIES IN itab. </CODE></p><p><STRONG>General Parameters:</STRONG></p><ul><li><STRONG>Only search for these tables: </STRONG>with this parameter you can restrict the search to a set of database tables.</li><li><STRONG>Minimum table size category: </STRONG>with this parameter you can restrict the search on those database operations that access database tables with a size category that is equal or larger than the parameter. The size category is maintained in the technical settings of a database table in the ABAP dictionary (SE11).</li><li><STRONG>Call&ndash;stack depth for analysis: </STRONG>this value determines how many levels of the call&ndash;stack will be analyzed below the loop statement. The default value is 3, the maximum value is 10.</li><li><STRONG>Exclude buffered tables: </STRONG>here it is possible to exclude accesses to buffered tables.</li><li><STRONG>Analyze only local procedures:</STRONG> here it is possible to restrict the evaluation to local procedures, which saves evaluation time.</li><li><STRONG>Restrict to object set:</STRONG> Only calls in procedures being contained in the object set of the inspection are analyzed</li><li><STRONG>Analyze reading db operations:</STRONG> analyze reading database operations inside a loop, i.e. SELECT, OPEN CURSOR, FETCH, CLOSE, and the obsolete ones READ TABLE dbtab and LOOP AT dbtab.</li><li><STRONG>Analyze writing db operations: </STRONG>analyze writing database operations inside a loop, i.e. DELETE, INSERT, UPDATE, and MODIFY.</li><li><STRONG>Analyze EXEC SQL statements: </STRONG>analyze exec sql statements inside a loop.</li><li><STRONG>Maximal Number of stacks shown:</STRONG> If there are several findings with a different stack (i.e. a different way to get to this finding), only show some of them.</li></ul><p></p><p><STRONG>Effort Parameters (determine the effort to correct a problematic statement)</STRONG></p><p><STRONG>Effort for db op in loop: </STRONG>with this parameter you determine the effort to remove a loop surrounding a database statement. The default value is 10.</p><p><STRONG>Effort for each call: </STRONG>with this parameter you determine the effort to remove a loop surrounding a procedure call that contains a database statement. The default value is 20.</p><p></p><p>The check delivers the following result messages. The pseudo comments to suppress the messages are indicated in brackets:</p><ul><li><STRONG>DBREAD_LOC</STRONG>&nbsp;&nbsp;A reading database operation was found inside a local loop (&quot;#EC CI_SEL_NESTED or &quot;#EC CI_SROFC_NESTED)</li><li><STRONG>DBREAD&nbsp;&nbsp;&nbsp;&nbsp;</STRONG>A reading database operation was found inside a non local loop. (&quot;#EC CI_SEL_NESTED or &quot;#EC CI_SROFC_NESTED)</li><li><STRONG>DBREAD_S&nbsp;&nbsp;&nbsp;&nbsp;</STRONG>A reading database operation was found as only statement inside a loop, this is easy to be transformed into an array operation. (&quot;#EC CI_SEL_NESTED or &quot;#EC CI_SROFC_NESTED)</li><li><STRONG>DBWRT_LOC</STRONG>&nbsp;&nbsp;A writing database operation was found inside a local loop. (&quot;#EC CI_IMUD_NESTED)</li><li><STRONG>DBWRITE&nbsp;&nbsp;&nbsp;&nbsp;</STRONG>A writing database operation was found inside a non local loop. (&quot;#EC CI_IMUD_NESTED)</li><li><STRONG>DBWRITE_S         </STRONG>A writing database operation was found as only statement inside a loop, this is easy to be transformed into an array operation. (&quot;#EC CI_IMUD_NESTED)</li><li><STRONG>EXEC_LOC</STRONG>&nbsp;&nbsp;&nbsp;&nbsp;An exec sql operation was found inside a local loop. (&quot;#EC CI_EXEC_SQL_NESTED)</li><li><STRONG>EXEC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</STRONG>An exec sql operation was found inside a non local loop. (&quot;#EC CI_EXEC_SQL_NESTED)</li></ul><p></p><p>If you have switched on to get detail information for the result,</p><p>you find the additional informations:</p><ul><li><STRONG>Table Name&nbsp;&nbsp;&nbsp;&nbsp;</STRONG>Name of the database table concerned</li><li><STRONG>Nr Loops&nbsp;&nbsp;&nbsp;&nbsp;</STRONG>Number of loops around the database operation</li><li><STRONG>Nr Calls&nbsp;&nbsp;&nbsp;&nbsp;</STRONG>Number of procedure calls around the database operation</li><li><STRONG>Effort</STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The effort to correct this problem.<br> It is calculated as follows:  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Effort = Effort for db op in loop +   Effort for each call * number of calls</li><li><STRONG>Severity</STRONG>&nbsp;&nbsp;&nbsp;&nbsp;The severity of this problem is a measure for the performance loss due to this problem.<br> It is calculated: Severity = number of loops</li></li></ul>"
    const x = await extractPragmas(doc)
    expect(x).toEqual([`"#EC CI_SEL_NESTED`])
})

test("subrc pseudocomment", async () => {
    const doc = "<h3>Details of Analysis</h3><p>No Handling of SY&ndash;SUBRC After Changing Database Statement</p><p>The message can be suppressed with pseudo comment CI_SUBRC</p><h3>What is checked? <a href=\"https://myserver.com/sap/public/bc/abap/toolsdocu?id=CA&obj=CL_CI_TEST_SYSUBRC%20%20%20%20%20%20%20%20%20%20%20%200000&lang=E&sap-language=EN&sap-client=100\">Handling</a><CODE>SY&ndash;SUBRC</CODE></h3><p>No handling of <CODE>SY&ndash;SUBRC</CODE> after a database write statement.</p><p><CODE>SY&ndash;SUBRC</CODE> is not handled after <CODE>INSERT</CODE>, <CODE>UPDATE</CODE>, <CODE>MODIFY</CODE>, or <CODE>DELETE</CODE>.</p><p>Check whether the return code</p><p><CODE>SY&ndash;SUBRC</CODE> needs to be handled after this statement.</p><p>The message can be hidden using the pseudo&ndash;comment <CODE>&quot;#EC CI_SUBRC</CODE>.</p><p></p><h2>Example</h2><p>See reference program<a href='adt://ACD/sap/bc/adt/programs/programs/rscid_subrc_db_change/source/main#start=1'> <STRONG>RSCID_SUBRC_DB_CHANGE</STRONG></a></p><p></p>"
    const x = await extractPragmas(doc)
    expect(x).toEqual([`"#EC CI_SUBRC`])
})
test("Extract noorder", async () => {
    const doc = "<h2>Details of Analysis</h2><p>Empty SELECT/ENDSELECT at /BTR/CL_MDR_PROGRAM===========CM00Z line 33</p><p>The message can be suppressed with pseudo comment CI_NOORDER</p><p></p><h2> <a href=\"https://myserver.com/sap/public/bc/abap/toolsdocu?id=TX&obj=S_CODE_INSPECTOR&lang=E&sap-language=EN&sap-client=100\">Code Inspector</a></h2><p>This check searches for <CODE>SELECT</CODE> and <CODE>OPEN CURSOR</CODE> statements where no <CODE>ORDER BY</CODE> clause is specified.</p><p>Afterwards <STRONG>problematic statements </STRONG>are searched which use the results of these <CODE>SELECT</CODE> or <CODE>OPEN CURSOR</CODE> statements. Problematic statements are statements which depend on the order of the entries of an internal table. The problematic statements are listed further below.</p><p>If the result of a <CODE>SELECT</CODE> or <CODE>OPEN CURSOR</CODE> statement is sorted by performing a SORT&ndash;Statement or by assigning to a sorted table the searching is aborted.</p><p>Some <CODE>SELECT </CODE>statements without <CODE>ORDER BY</CODE> clause are analyzed independently of problematic statements afterwards:</p><p><CODE>SELECT SINGLE </CODE>are problematic and lead to message AMB_SINGLE if they are ambiguous, i.e. if the <CODE>WHERE </CODE>condition does not specify a full key of the database table.  If the <CODE>SELECT SINGLE </CODE>statement contains a <CODE>JOIN</CODE> or the result of an ambiguous <CODE>SELECT SINGLE</CODE>statement is not used no message is thrown.</p><p><CODE>SELECT UP TO n ROWS </CODE>statements <CODE>ORDER BY</CODE> clause lead to message SEL_UP_TO.</p><p>Empty <CODE>SELECT</CODE> statements without  <CODE>ORDER BY</CODE> clause lead to message EMPTY_SEL and <CODE>EXIT</CODE> statements inside of <CODE>SELECT</CODE> statements without <CODE>ORDER BY</CODE> clause also lead to message SEL_EXIT.</p><p><CODE>WRITE</CODE> statements inside a <CODE>SELECT</CODE> statement without <CODE>ORDER BY</CODE> clause referring to the <CODE>SELECT </CODE>targets lead to a message SEL_WRITE.</p><p></p><p><STRONG>Check parameters:</STRONG></p><ul><li>Only local calls: With this parameter you can specify if external procedure call should be analyzed, too.</li><li>Report access to Pool/Cluster table: Controls whether the messages SEL_POOL/CLUST or OPEN_POOL/CLUST are raised.</li><li>Non&ndash;local analysis depth: With this parameter you can specify the maximal evaluation depth into external programs.</li></ul><p></p><p>If a SELECT or OPEN CURSOR  statement without ORDER BY is found for a pool or cluster table a message is raised even if no problematic statement is found for it, because the order of the returned database entries changes if the database table is modified into a transparent table. For access to pool or cluster tables without problematic statement the following Message&ndash;Codes are used:</p><p>SEL_POOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select statement for pool table</p><p>SELS_POOL&nbsp;&nbsp;&nbsp;&nbsp;select statement for pool table into sorted internal table</p><p>SEL_CLUST&nbsp;&nbsp;&nbsp;&nbsp;select statement for cluster table</p><p>SELS_CLUST&nbsp;&nbsp;&nbsp;&nbsp;select statement for cluster table into sorted internal table</p><p>OPEN_POOL&nbsp;&nbsp;&nbsp;&nbsp;open statement for pool table</p><p>OPEN_CLUST&nbsp;&nbsp;&nbsp;&nbsp;open statement for cluster table</p><p>The messages above are issued in addition to the following messages.</p><p></p><p>The problematic statements are:</p><table border=&quot;1&quot; cellpadding=&quot;10&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;><tr><td><strong><CODE>READ TABLE itab ... BINARY SEARCH</CODE></td><td>(Message&ndash;Code BIN_SEARCH)</td></tr><tr><td><CODE>DELETE ADJECENT DUPLICATES FROM itab.</CODE></td><td>(Message&ndash;Code DELETE_ADJ)</td></tr><tr><td><CODE>LOOP AT itab. AT NEW/END OF ... ENDAT. ENDLOOP.</CODE></td><td>(Message&ndash;Code LOOP_AT)</td></tr><tr><td><CODE>LOOP AT itab. AT FIRST/LAST ... ENDAT. ENDLOOP.</CODE></td><td>(Message&ndash;Code LOOP_AT_FL)</td></tr><tr><td><CODE>PROVIDE ... ENDPROVIDE.</CODE></td><td>(Message&ndash;Code PROVIDE)</td></tr><tr><td> The messages above can be suppressed via the pseudo comment   &quot;#EC CI_SORTED  </td></tr></table><p></p><table border=&quot;1&quot; cellpadding=&quot;10&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;><tr><td><strong><CODE>READ TABLE itab ... INDEX 1.</CODE></td><td>(Message&ndash;Code READ_IDX_1)</td></tr><tr><td><CODE>READ TABLE itab ... INDEX const</CODE></td><td>(Message&ndash;Code READ_IDX_C)</td></tr><tr><td><CODE>READ TABLE itab ... INDEX var</CODE></td><td>(Message&ndash;Code READ_IDX)</td></tr><tr><td><CODE>READ TABLE itab ... WITH KEY ...</CODE></td><td>(Message&ndash;Code PART_KEY, deactivated by default (see below))</td></tr><tr><td> <CODE>LOOP AT itab ... FROM from TO to</CODE></td><td>(Message&ndash;Code LOOP_FR/TO)</td></tr><tr><td><CODE>MODIFY itab INDEX i</CODE></td><td>(Message&ndash;Code MODIFY_IDX)</td></tr><tr><td><CODE>DELETE itab INDEX i</CODE></td><td>(Message&ndash;Code DEL_IDX)</td></tr><tr><td><CODE>DELETE itab FROM from TO to</CODE></td><td>(Message&ndash;Code DEL_FR/TO)</td></tr><tr><td> <CODE>LOOP AT itab. EXIT/RETURN/LEAVE. </CODE></td><td>(Message&ndash;Code LOOP_EXIT)</td></tr><tr><td> <CODE>CONCATENATE LINES OF itab INTO str </CODE></td><td>(Message&ndash;Code CONCAT)</td></tr><tr><td><CODE>FIND str IN itab</CODE></td><td>(Message&ndash;Code FIND)</td></tr><tr><td><CODE>REPLACE str1 IN itab WITH str2</CODE></td><td>(Message&ndash;Code REPLACE)</td></tr><tr><td><CODE>SEARCH str IN itab</CODE></td><td>(Message&ndash;Code SEARCH)</td></tr><tr><td><CODE>IF itab = ...</td><td></CODE>(Message&ndash;Code EQUAL_TEST)</td></tr><tr><td><CODE>WHEN itab = ...</td><td></CODE>(Message&ndash;Code EQUAL_TEST)</td></tr><tr><td><CODE>CL_SALV_TABLE=>FACTORY( CHANGING t_table = itab )  </CODE>  (Message&ndash;Code ALV_CALL) <CODE>LOOP AT itab. WRITE..    </CODE>(Message&ndash;Code LOOP_WRITE)   The messages above can be suppressed via the pseudo comment   &quot;#EC CI_NOORDER</td></tr></table><p>The pseudo comment has to be placed at the statement where message is raised (e.g. the <CODE>READ TABLE itab ... BINARY SEARCH statement).</CODE></p><p></p><table border=&quot;1&quot; cellpadding=&quot;10&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;><tr><td><strong><CODE>SELECT SINGLE ...  </CODE></td><td></td><td>(Message&ndash;Code AMB_SINGLE)</td></tr></table><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;               shows ambiguous select singles</p><p>This message can be suppressed via the pseudo comments</p><p>&quot;#EC CI_NOORDER or &quot;#EC WARN_OK</p><p></p><p>The message code PART_KEY is special in that it is configured to yield no finding by default since its false positive rate can be very high. It detects READ statements on internal tables that (together with the WHERE condition of the corresponding SELECT statement) do not specify the complete primary key of the database table. This technically means that the result of the READ is not guaranteed to be unique, but there are many cases in which uniqueness is ensured by the semantics of the data model instead.</p><p>If you want to see findings of this type, you should customize the priority of this message code to something other than &quot;No message&quot;.</p><p></p><p><STRONG>What you can do:</STRONG></p><p>There are several possibilities:</p><ul><li>Add an <CODE>ORDER BY</CODE> clause to the select statement</li><li>Add a <CODE>SORT</CODE> statement for the internal table</li><li>An ambiguous <CODE>SELECT SINGLE </CODE>statement can be turned to an unambiguous one in changing the <CODE>WHERE</CODE> condition so that it specifies a full key and the <CODE>FROM</CODE> clause so that it does not contain <CODE>JOINS</CODE>.</li><li>If no problem exists add the specified pseudo comment</li></ul><p><STRONG>Remark:</STRONG> The <CODE>SELECT</CODE> statement and the critical statement can be in different subroutines.</p><p></p><p></p><p></p><p></p><p></p><p></p>"
    const x = await extractPragmas(doc)
    expect(x).toEqual([`"#EC CI_NOORDER`])
})
test("multiple options", async () => {
    const doc = "<h3>Details of Analysis</h3><ul><li>Access to single record buffered table RFCDES cannot use buffer<a href='adt://A4H/sap/bc/adt/programs/programs/zdemo1/source/main#start=24,0'></li></ul><p></a></p><ul><li>Finding can be suppressed with pseudo comment &quot;#EC CI_GENBUFF or &quot;#EC CI_SGLSELECT</li></ul><h3>What is checked?</h3><p><a href=\"http://vhcala4hci:50000/sap/bc/abap/toolsdocu?id=CA&obj=CL_CI_TEST_SELECT_TAW_BYBUF%20%20%200000&lang=E&sap-language=EN&sap-client=001\"><CODE>SELECT</CODE> statements that bypass the SAP table buffer</a></p><p>The buffer cannot be used to access single-record-buffered tables.</p><p>The SAP table buffer can only be used with single-record-buffered tables if the primary key in the <CODE>WHERE</CODE> condition is fully specified. Only fields with a <CODE>=</CODE> or <CODE>EQ</CODE> condition can be evaluated here. The fields of the primary key can only be joined by <CODE>AND</CODE> conditions, and not by <CODE>OR</CODE> conditions.</p><p>From NW 7.40, the option '<CODE>FOR ALL ENTRIES</CODE>' no longer bypasses the table buffer.in the case of single-record buffered tables.</p><p>If the <CODE>WHERE</CODE> condition contains a single key field in a selection table or an <CODE>IN</CODE> list (for example, <CODE>WHERE a IN SELTAB</CODE> with <CODE>SELTAB-sign = 'I', SELTAB-option = 'EQ', SELTAB-low = 'test'</CODE> -- or <CODE>WHERE a IN ('test')</CODE>), this statement can use the SAP table buffer; however this is ignored by Code Inspector.</p><p>This message can be hidden using the pseudo comment <CODE>&quot;#EC CI_GENBUFF</CODE>.</p>"
    const x = await extractPragmas(doc)
    expect(x).toEqual([`"#EC CI_GENBUFF`, `"#EC CI_SGLSELECT`])
})

test("Pragma as code", async () => {
    const doc = "<p>Details of Analysis</p><p> Syntax check warning. After a structure enhancement, the semantics of the assignment or comparison may change. Internal message code: MESSAGE G:O</p><p>The semantics of the assignment or the comparison might change after a structure enhancement.</p><p>One of the structures can be enhanced. The enhancement could change the semantics of the assignment.</p><p>One of the structures can be enhanced. Even though the enhancement cannot cause a syntax error, multiple naming of components, for example, could change the assignment semantics.</p><p>Troubleshooting: This warning is triggered because the data type <CODE>/BTI/TE_ST_CUSTFVALS</CODE> can be deeply enhanced. In SE11, you can set this data type to &quot;cannot be enhanced&quot;.</p><p>This message can be handled using a pragma (refer to <a href=\"https://mysite.com/sap/public/bc/abap/docu?sap-language=EN&sap-client=100&format=ECLIPSE&object=ABENPRAGMA\"> Pragmas</a>).</p><p>Pragma (compulsory parameters highlighted):</p><p><CODE>ENH_OK</CODE></p>"
    const x = await extractPragmas(doc)
    expect(x).toEqual(["##ENH_OK"])
})

test("Pragma insert", async () => {
    const pos = insertPosition("    catch cx_root into lo_ex.", "##CATCH_ALL")
    expect(pos).toBe(28)
})

test("Pragma insert with comments", async () => {
    const pos = insertPosition('    catch cx_root into lo_ex. "whatever', "##CATCH_ALL")
    expect(pos).toBe(28)
})

test("pseudocomment insert", async () => {
    const pos = insertPosition("  SELECT * FROM mara INTO TABLE itab.", '"#EC CI_NOWHERE')
    expect(pos).toBe(37)
})

test("pseudocomment insert with comments", async () => {
    const pos = insertPosition('  SELECT * FROM mara INTO TABLE itab."whatever', '"#EC CI_NOWHERE')
    expect(pos).toBe(37)
})

test("Pragma ignore strings", async () => {
    const pos = insertPosition(`    data:f value '""',i value '" x'. "foo""'"'`, "##CATCH_ALL")
    expect(pos).toBe(35)
})